{"ast":null,"code":"var _classCallCheck = require(\"C:/Users/HARSH/Downloads/CHAT_APPLICATION-main (1)/CHAT_APPLICATION-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/HARSH/Downloads/CHAT_APPLICATION-main (1)/CHAT_APPLICATION-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _toConsumableArray = require(\"C:/Users/HARSH/Downloads/CHAT_APPLICATION-main (1)/CHAT_APPLICATION-main/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n// eslint-disable-next-line no-unused-vars\nvar _require = require('./inline-text-builder'),\n  InlineTextBuilder = _require.InlineTextBuilder;\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\nfunction charactersToCodes(str) {\n  return _toConsumableArray(str).map(function (c) {\n    return \"\\\\u\" + c.charCodeAt(0).toString(16).padStart(4, '0');\n  }).join('');\n}\n\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\nvar WhitespaceProcessor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  function WhitespaceProcessor(options) {\n    _classCallCheck(this, WhitespaceProcessor);\n    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\\n/g, '') : options.whitespaceCharacters;\n    var whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(\"^[\".concat(whitespaceCodes, \"]\"));\n    this.trailingWhitespaceRe = new RegExp(\"[\".concat(whitespaceCodes, \"]$\"));\n    this.allWhitespaceOrEmptyRe = new RegExp(\"^[\".concat(whitespaceCodes, \"]*$\"));\n    if (options.preserveNewlines) {\n      var wordOrNewlineRe = new RegExp(\"\\n|[^\\n\".concat(whitespaceCodes, \"]+\"), 'gm');\n\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       */\n      this.shrinkWrapAdd = function (text, inlineTextBuilder) {\n        var transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (str) {\n          return str;\n        };\n        if (!text) {\n          return;\n        }\n        var previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        var anyMatch = false;\n        var m = wordOrNewlineRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]));\n          }\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]));\n            }\n          }\n        }\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n        // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n    } else {\n      var wordRe = new RegExp(\"[^\".concat(whitespaceCodes, \"]+\"), 'g');\n      this.shrinkWrapAdd = function (text, inlineTextBuilder) {\n        var transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (str) {\n          return str;\n        };\n        if (!text) {\n          return;\n        }\n        var previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        var anyMatch = false;\n        var m = wordRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]));\n          }\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          }\n        }\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n      };\n    }\n  }\n\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  _createClass(WhitespaceProcessor, [{\n    key: \"testLeadingWhitespace\",\n    value: function testLeadingWhitespace(text) {\n      return this.leadingWhitespaceRe.test(text);\n    }\n\n    /**\n     * Test whether the given text ends with HTML whitespace character.\n     *\n     * @param   { string }  text  The string to test.\n     * @returns { boolean }\n     */\n  }, {\n    key: \"testTrailingWhitespace\",\n    value: function testTrailingWhitespace(text) {\n      return this.trailingWhitespaceRe.test(text);\n    }\n\n    /**\n     * Test whether the given text contains any non-whitespace characters.\n     *\n     * @param   { string }  text  The string to test.\n     * @returns { boolean }\n     */\n  }, {\n    key: \"testContainsWords\",\n    value: function testContainsWords(text) {\n      return !this.allWhitespaceOrEmptyRe.test(text);\n    }\n  }]);\n  return WhitespaceProcessor;\n}();\nmodule.exports = {\n  WhitespaceProcessor: WhitespaceProcessor\n};","map":{"version":3,"names":["_require","require","InlineTextBuilder","charactersToCodes","str","_toConsumableArray","map","c","charCodeAt","toString","padStart","join","WhitespaceProcessor","options","_classCallCheck","whitespaceChars","preserveNewlines","whitespaceCharacters","replace","whitespaceCodes","leadingWhitespaceRe","RegExp","concat","trailingWhitespaceRe","allWhitespaceOrEmptyRe","wordOrNewlineRe","shrinkWrapAdd","text","inlineTextBuilder","transform","arguments","length","undefined","previouslyStashedSpace","stashedSpace","anyMatch","m","exec","startNewLine","testLeadingWhitespace","pushWord","concatWord","testTrailingWhitespace","wordRe","_createClass","key","value","test","testContainsWords","module","exports"],"sources":["C:/Users/HARSH/Downloads/CHAT_APPLICATION-main (1)/CHAT_APPLICATION-main/node_modules/html-to-text/lib/whitespace-processor.js"],"sourcesContent":["\n// eslint-disable-next-line no-unused-vars\nconst { InlineTextBuilder } = require('./inline-text-builder');\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n\nfunction charactersToCodes (str) {\n  return [...str]\n    .map(c => '\\\\u' + c.charCodeAt(0).toString(16).padStart(4, '0'))\n    .join('');\n}\n\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\nclass WhitespaceProcessor {\n\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  constructor (options) {\n    this.whitespaceChars = (options.preserveNewlines)\n      ? options.whitespaceCharacters.replace(/\\n/g, '')\n      : options.whitespaceCharacters;\n    const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n\n    if (options.preserveNewlines) {\n\n      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, 'gm');\n\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       */\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str)) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordOrNewlineRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]));\n          }\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]));\n            }\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || (this.testTrailingWhitespace(text));\n        // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n\n    } else {\n\n      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');\n\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str)) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]));\n          }\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]));\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || this.testTrailingWhitespace(text);\n      };\n\n    }\n  }\n\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testLeadingWhitespace (text) {\n    return this.leadingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testTrailingWhitespace (text) {\n    return this.trailingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testContainsWords (text) {\n    return !this.allWhitespaceOrEmptyRe.test(text);\n  }\n\n}\n\nmodule.exports = { WhitespaceProcessor: WhitespaceProcessor };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}