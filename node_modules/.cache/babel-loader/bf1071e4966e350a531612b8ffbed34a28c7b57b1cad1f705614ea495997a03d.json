{"ast":null,"code":"var _classCallCheck = require(\"C:/Users/HARSH/Downloads/CHAT_APPLICATION-main (1)/CHAT_APPLICATION-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/HARSH/Downloads/CHAT_APPLICATION-main (1)/CHAT_APPLICATION-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require('./helper'),\n  trimCharacter = _require.trimCharacter;\n// eslint-disable-next-line no-unused-vars\nvar _require2 = require('./stack-item'),\n  StackItem = _require2.StackItem,\n  BlockStackItem = _require2.BlockStackItem,\n  TableCellStackItem = _require2.TableCellStackItem,\n  TableRowStackItem = _require2.TableRowStackItem,\n  TableStackItem = _require2.TableStackItem,\n  TransformerStackItem = _require2.TransformerStackItem;\nvar _require3 = require('./table-printer'),\n  tableToString = _require3.tableToString;\nvar _require4 = require('./whitespace-processor'),\n  WhitespaceProcessor = _require4.WhitespaceProcessor;\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nvar BlockTextBuilder = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   */\n  function BlockTextBuilder(options) {\n    _classCallCheck(this, BlockTextBuilder);\n    this.options = options;\n    this.whitepaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  _createClass(BlockTextBuilder, [{\n    key: \"pushWordTransform\",\n    value: function pushWordTransform(wordTransform) {\n      this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n    }\n\n    /**\n     * Remove a function from the word transformations stack.\n     *\n     * @returns { (str: string) => string } A function that was removed.\n     */\n  }, {\n    key: \"popWordTransform\",\n    value: function popWordTransform() {\n      if (!this._wordTransformer) {\n        return undefined;\n      }\n      var transform = this._wordTransformer.transform;\n      this._wordTransformer = this._wordTransformer.next;\n      return transform;\n    }\n\n    /** @returns { (str: string) => string } */\n  }, {\n    key: \"_getCombinedWordTransformer\",\n    value: function _getCombinedWordTransformer() {\n      var _this = this;\n      var applyTransformer = function applyTransformer(str, transformer) {\n        return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n      };\n      return function (str) {\n        return applyTransformer(str, _this._wordTransformer);\n      };\n    }\n  }, {\n    key: \"_popStackItem\",\n    value: function _popStackItem() {\n      var item = this._stackItem;\n      this._stackItem = item.next;\n      return item;\n    }\n\n    /**\n     * Add a line break into currently built block.\n     */\n  }, {\n    key: \"addLineBreak\",\n    value: function addLineBreak() {\n      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n        return;\n      }\n      if (this._stackItem.isPre) {\n        this._stackItem.rawText += '\\n';\n      } else {\n        this._stackItem.inlineTextBuilder.startNewLine();\n      }\n    }\n\n    /**\n     * Allow to break line in case directly following text will not fit.\n     */\n  }, {\n    key: \"addWordBreakOpportunity\",\n    value: function addWordBreakOpportunity() {\n      if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem) {\n        this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n      }\n    }\n\n    /**\n     * Add a node inline into the currently built block.\n     *\n     * @param { string } str\n     * Text content of a node to add.\n     *\n     * @param { object | boolean } [ optionsObjectOrNoWordTransform ]\n     * Object holding the parameters of the operation.\n     *\n     * Boolean value is deprecated.\n     *\n     * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]\n     * Ignore word transformers if there are any.\n     */\n  }, {\n    key: \"addInline\",\n    value: function addInline(str) {\n      var optionsObjectOrNoWordTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (typeof optionsObjectOrNoWordTransform === 'object') {\n        this._addInline(str, optionsObjectOrNoWordTransform);\n      } else {\n        this._addInline(str, {\n          noWordTransform: optionsObjectOrNoWordTransform\n        });\n      }\n    }\n  }, {\n    key: \"_addInline\",\n    value: function _addInline(str) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$noWordTransform = _ref.noWordTransform,\n        noWordTransform = _ref$noWordTransform === void 0 ? false : _ref$noWordTransform;\n      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n        return;\n      }\n      if (this._stackItem.isPre) {\n        this._stackItem.rawText += str;\n        return;\n      }\n      if (this.whitepaceProcessor.testContainsWords(str) ||\n      // There are words to add;\n      str.length && !this._stackItem.stashedLineBreaks // or at least spaces to take into account.\n      ) {\n        if (this._stackItem.stashedLineBreaks) {\n          this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n        }\n        this.whitepaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, this._wordTransformer && !noWordTransform ? this._getCombinedWordTransformer() : undefined);\n        this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n      }\n    }\n\n    /**\n     * Start building a new block.\n     *\n     * @param { object | number } [optionsObjectOrLeadingLineBreaks]\n     * Object holding the parameters of the block.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]\n     * This block should have at least this number of line breaks to separate if from any preceding block.\n     *\n     * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]\n     * Reserve this number of characters on each line for block markup.\n     *\n     * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]\n     * Should HTML whitespace be preserved inside this block.\n     *\n     * @param { number }  [reservedLineLength]\n     * Deprecated.\n     *\n     * @param { boolean } [isPre]\n     * Deprecated.\n     */\n  }, {\n    key: \"openBlock\",\n    value: function openBlock() {\n      var optionsObjectOrLeadingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var reservedLineLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var isPre = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      if (typeof optionsObjectOrLeadingLineBreaks === 'object') {\n        this._openBlock(optionsObjectOrLeadingLineBreaks);\n      } else {\n        this._openBlock({\n          isPre: isPre,\n          leadingLineBreaks: optionsObjectOrLeadingLineBreaks,\n          reservedLineLength: reservedLineLength\n        });\n      }\n    }\n  }, {\n    key: \"_openBlock\",\n    value: function _openBlock() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$leadingLineBrea = _ref2.leadingLineBreaks,\n        leadingLineBreaks = _ref2$leadingLineBrea === void 0 ? 1 : _ref2$leadingLineBrea,\n        _ref2$reservedLineLen = _ref2.reservedLineLength,\n        reservedLineLength = _ref2$reservedLineLen === void 0 ? 0 : _ref2$reservedLineLen,\n        _ref2$isPre = _ref2.isPre,\n        isPre = _ref2$isPre === void 0 ? false : _ref2$isPre;\n      var maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n      this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n      if (isPre) {\n        this._stackItem.isPre = true;\n      }\n    }\n\n    /**\n     * Finalize currently built block, add it's content to the parent block.\n     *\n     * @param { object | number }         [optionsObjectOrTrailingLineBreaks]\n     * Object holding the parameters of the block.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]\n     * This block should have at least this number of line breaks to separate it from any following block.\n     *\n     * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]\n     * A function to transform the block text before adding to the parent block.\n     * This happens after word wrap and should be used in combination with reserved line length\n     * in order to keep line lengths correct.\n     * Used for whole block markup.\n     *\n     * @param { (str: string) => string } [blockTransform]\n     * Deprecated.\n     */\n  }, {\n    key: \"closeBlock\",\n    value: function closeBlock() {\n      var optionsObjectOrTrailingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var blockTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (typeof optionsObjectOrTrailingLineBreaks === 'object') {\n        this._closeBlock(optionsObjectOrTrailingLineBreaks);\n      } else {\n        this._closeBlock({\n          trailingLineBreaks: optionsObjectOrTrailingLineBreaks,\n          blockTransform: blockTransform\n        });\n      }\n    }\n  }, {\n    key: \"_closeBlock\",\n    value: function _closeBlock() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$trailingLineBre = _ref3.trailingLineBreaks,\n        trailingLineBreaks = _ref3$trailingLineBre === void 0 ? 1 : _ref3$trailingLineBre,\n        _ref3$blockTransform = _ref3.blockTransform,\n        blockTransform = _ref3$blockTransform === void 0 ? undefined : _ref3$blockTransform;\n      var block = this._popStackItem();\n      var blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n      addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n    }\n\n    /**\n     * Start building a table.\n     */\n  }, {\n    key: \"openTable\",\n    value: function openTable() {\n      this._stackItem = new TableStackItem(this._stackItem);\n    }\n\n    /**\n     * Start building a table row.\n     */\n  }, {\n    key: \"openTableRow\",\n    value: function openTableRow() {\n      if (!(this._stackItem instanceof TableStackItem)) {\n        throw new Error('Can\\'t add table row to something that is not a table! Check the formatter.');\n      }\n      this._stackItem = new TableRowStackItem(this._stackItem);\n    }\n\n    /**\n     * Start building a table cell.\n     *\n     * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]\n     * Object holding the parameters of the cell.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]\n     * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n     */\n  }, {\n    key: \"openTableCell\",\n    value: function openTableCell() {\n      var optionsObjectOrMaxColumnWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (typeof optionsObjectOrMaxColumnWidth === 'object') {\n        this._openTableCell(optionsObjectOrMaxColumnWidth);\n      } else {\n        this._openTableCell({\n          maxColumnWidth: optionsObjectOrMaxColumnWidth\n        });\n      }\n    }\n  }, {\n    key: \"_openTableCell\",\n    value: function _openTableCell() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$maxColumnWidth = _ref4.maxColumnWidth,\n        maxColumnWidth = _ref4$maxColumnWidth === void 0 ? undefined : _ref4$maxColumnWidth;\n      if (!(this._stackItem instanceof TableRowStackItem)) {\n        throw new Error('Can\\'t add table cell to something that is not a table row! Check the formatter.');\n      }\n      this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n    }\n\n    /**\n     * Finalize currently built table cell and add it to parent table row's cells.\n     *\n     * @param { object | number } [optionsObjectOrColspan]\n     * Object holding the parameters of the cell.\n     *\n     * Number value is deprecated.\n     *\n     * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.\n     * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.\n     *\n     * @param { number } [rowspan] Deprecated.\n     */\n  }, {\n    key: \"closeTableCell\",\n    value: function closeTableCell() {\n      var optionsObjectOrColspan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var rowspan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (typeof optionsObjectOrColspan === 'object') {\n        this._closeTableCell(optionsObjectOrColspan);\n      } else {\n        this._closeTableCell({\n          colspan: optionsObjectOrColspan,\n          rowspan: rowspan\n        });\n      }\n    }\n  }, {\n    key: \"_closeTableCell\",\n    value: function _closeTableCell() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref5$colspan = _ref5.colspan,\n        colspan = _ref5$colspan === void 0 ? 1 : _ref5$colspan,\n        _ref5$rowspan = _ref5.rowspan,\n        rowspan = _ref5$rowspan === void 0 ? 1 : _ref5$rowspan;\n      var cell = this._popStackItem();\n      var text = trimCharacter(getText(cell), '\\n');\n      cell.next.cells.push({\n        colspan: colspan,\n        rowspan: rowspan,\n        text: text\n      });\n    }\n\n    /**\n     * Finalize currently built table row and add it to parent table's rows.\n     */\n  }, {\n    key: \"closeTableRow\",\n    value: function closeTableRow() {\n      var row = this._popStackItem();\n      row.next.rows.push(row.cells);\n    }\n\n    /**\n     * Finalize currently built table and add the rendered text to the parent block.\n     *\n     * @param { object | number } [optionsObjectOrColSpacing]\n     * Object holding the parameters of the table.\n     *\n     * Number value is depreceted.\n     *\n     * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]\n     * Number of spaces between table columns.\n     *\n     * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]\n     * Number of empty lines between table rows.\n     *\n     * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]\n     * This table should have at least this number of line breaks to separate if from any preceding block.\n     *\n     * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]\n     * This table should have at least this number of line breaks to separate it from any following block.\n     *\n     * @param { number } [rowSpacing]\n     * Deprecated.\n     *\n     * @param { number } [leadingLineBreaks]\n     * Deprecated.\n     *\n     * @param { number } [trailingLineBreaks]\n     * Deprecated.\n     */\n  }, {\n    key: \"closeTable\",\n    value: function closeTable() {\n      var optionsObjectOrColSpacing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var rowSpacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var leadingLineBreaks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var trailingLineBreaks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      if (typeof optionsObjectOrColSpacing === 'object') {\n        this._closeTable(optionsObjectOrColSpacing);\n      } else {\n        this._closeTable({\n          colSpacing: optionsObjectOrColSpacing,\n          leadingLineBreaks: leadingLineBreaks,\n          rowSpacing: rowSpacing,\n          trailingLineBreaks: trailingLineBreaks\n        });\n      }\n    }\n  }, {\n    key: \"_closeTable\",\n    value: function _closeTable() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref6$colSpacing = _ref6.colSpacing,\n        colSpacing = _ref6$colSpacing === void 0 ? 3 : _ref6$colSpacing,\n        _ref6$rowSpacing = _ref6.rowSpacing,\n        rowSpacing = _ref6$rowSpacing === void 0 ? 0 : _ref6$rowSpacing,\n        _ref6$leadingLineBrea = _ref6.leadingLineBreaks,\n        leadingLineBreaks = _ref6$leadingLineBrea === void 0 ? 2 : _ref6$leadingLineBrea,\n        _ref6$trailingLineBre = _ref6.trailingLineBreaks,\n        trailingLineBreaks = _ref6$trailingLineBre === void 0 ? 2 : _ref6$trailingLineBre;\n      var table = this._popStackItem();\n      var output = tableToString(table.rows, rowSpacing, colSpacing);\n      if (output) {\n        addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n      }\n    }\n\n    /**\n     * Return the rendered text content of this builder.\n     *\n     * @returns { string }\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return getText(this._stackItem.getRoot());\n      // There should only be the root item if everything is closed properly.\n    }\n  }]);\n  return BlockTextBuilder;\n}();\nfunction getText(stackItem) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can be requested for text contents.');\n  }\n  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can contain text.');\n  }\n  var parentText = getText(stackItem);\n  var lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\nmodule.exports = {\n  BlockTextBuilder: BlockTextBuilder\n};","map":{"version":3,"names":["_require","require","trimCharacter","_require2","StackItem","BlockStackItem","TableCellStackItem","TableRowStackItem","TableStackItem","TransformerStackItem","_require3","tableToString","_require4","WhitespaceProcessor","BlockTextBuilder","options","_classCallCheck","whitepaceProcessor","_stackItem","_wordTransformer","undefined","_createClass","key","value","pushWordTransform","wordTransform","popWordTransform","transform","next","_getCombinedWordTransformer","_this","applyTransformer","str","transformer","_popStackItem","item","addLineBreak","isPre","rawText","inlineTextBuilder","startNewLine","addWordBreakOpportunity","wordBreakOpportunity","addInline","optionsObjectOrNoWordTransform","arguments","length","_addInline","noWordTransform","_ref","_ref$noWordTransform","testContainsWords","stashedLineBreaks","shrinkWrapAdd","openBlock","optionsObjectOrLeadingLineBreaks","reservedLineLength","_openBlock","leadingLineBreaks","_ref2","_ref2$leadingLineBrea","_ref2$reservedLineLen","_ref2$isPre","maxLineLength","Math","max","closeBlock","optionsObjectOrTrailingLineBreaks","blockTransform","_closeBlock","trailingLineBreaks","_ref3","_ref3$trailingLineBre","_ref3$blockTransform","block","blockText","getText","addText","openTable","openTableRow","Error","openTableCell","optionsObjectOrMaxColumnWidth","_openTableCell","maxColumnWidth","_ref4","_ref4$maxColumnWidth","closeTableCell","optionsObjectOrColspan","rowspan","_closeTableCell","colspan","_ref5","_ref5$colspan","_ref5$rowspan","cell","text","cells","push","closeTableRow","row","rows","closeTable","optionsObjectOrColSpacing","rowSpacing","_closeTable","colSpacing","_ref6","_ref6$colSpacing","_ref6$rowSpacing","_ref6$leadingLineBrea","_ref6$trailingLineBre","table","output","toString","getRoot","stackItem","isEmpty","parentText","lineBreaks","clear","repeat","module","exports"],"sources":["C:/Users/HARSH/Downloads/CHAT_APPLICATION-main (1)/CHAT_APPLICATION-main/node_modules/html-to-text/lib/block-text-builder.js"],"sourcesContent":["\nconst { trimCharacter } = require('./helper');\n// eslint-disable-next-line no-unused-vars\nconst { StackItem, BlockStackItem, TableCellStackItem, TableRowStackItem, TableStackItem, TransformerStackItem }\n  = require('./stack-item');\nconst { tableToString } = require('./table-printer');\nconst { WhitespaceProcessor } = require('./whitespace-processor');\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   */\n  constructor (options) {\n    this.options = options;\n    this.whitepaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform (wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform () {\n    if (!this._wordTransformer) { return undefined; }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer () {\n    const applyTransformer = (str, transformer) =>\n      ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);\n    return (str) => applyTransformer(str, this._wordTransformer);\n  }\n\n  _popStackItem () {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak () {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity () {\n    if (\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    ) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object | boolean } [ optionsObjectOrNoWordTransform ]\n   * Object holding the parameters of the operation.\n   *\n   * Boolean value is deprecated.\n   *\n   * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]\n   * Ignore word transformers if there are any.\n   */\n  addInline (str, optionsObjectOrNoWordTransform = {}) {\n    if (typeof optionsObjectOrNoWordTransform === 'object') {\n      this._addInline(str, optionsObjectOrNoWordTransform);\n    } else {\n      this._addInline(str, { noWordTransform: optionsObjectOrNoWordTransform });\n    }\n  }\n\n  _addInline (str, { noWordTransform = false } = {}) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (\n      this.whitepaceProcessor.testContainsWords(str) || // There are words to add;\n      (str.length && !this._stackItem.stashedLineBreaks) // or at least spaces to take into account.\n    ) {\n      if (this._stackItem.stashedLineBreaks) {\n        this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n      }\n      this.whitepaceProcessor.shrinkWrapAdd(\n        str,\n        this._stackItem.inlineTextBuilder,\n        (this._wordTransformer && !noWordTransform) ? this._getCombinedWordTransformer() : undefined\n      );\n      this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n    }\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object | number } [optionsObjectOrLeadingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]\n   * Should HTML whitespace be preserved inside this block.\n   *\n   * @param { number }  [reservedLineLength]\n   * Deprecated.\n   *\n   * @param { boolean } [isPre]\n   * Deprecated.\n   */\n  openBlock (optionsObjectOrLeadingLineBreaks = {}, reservedLineLength = undefined, isPre = undefined) {\n    if (typeof optionsObjectOrLeadingLineBreaks === 'object') {\n      this._openBlock(optionsObjectOrLeadingLineBreaks);\n    } else {\n      this._openBlock({\n        isPre: isPre,\n        leadingLineBreaks: optionsObjectOrLeadingLineBreaks,\n        reservedLineLength: reservedLineLength,\n      });\n    }\n  }\n\n  _openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(\n      this.options,\n      this._stackItem,\n      leadingLineBreaks,\n      maxLineLength\n    );\n    if (isPre) { this._stackItem.isPre = true; }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object | number }         [optionsObjectOrTrailingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   *\n   * @param { (str: string) => string } [blockTransform]\n   * Deprecated.\n   */\n  closeBlock (optionsObjectOrTrailingLineBreaks = {}, blockTransform = undefined) {\n    if (typeof optionsObjectOrTrailingLineBreaks === 'object') {\n      this._closeBlock(optionsObjectOrTrailingLineBreaks);\n    } else {\n      this._closeBlock({\n        trailingLineBreaks: optionsObjectOrTrailingLineBreaks,\n        blockTransform: blockTransform,\n      });\n    }\n  }\n\n  _closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n    const block = this._popStackItem();\n    const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable () {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow () {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell (optionsObjectOrMaxColumnWidth = {}) {\n    if (typeof optionsObjectOrMaxColumnWidth === 'object') {\n      this._openTableCell(optionsObjectOrMaxColumnWidth);\n    } else {\n      this._openTableCell({ maxColumnWidth: optionsObjectOrMaxColumnWidth });\n    }\n  }\n\n  _openTableCell ({ maxColumnWidth = undefined } = {}) {\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object | number } [optionsObjectOrColspan]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.\n   * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.\n   *\n   * @param { number } [rowspan] Deprecated.\n   */\n  closeTableCell (optionsObjectOrColspan = {}, rowspan = undefined) {\n    if (typeof optionsObjectOrColspan === 'object') {\n      this._closeTableCell(optionsObjectOrColspan);\n    } else {\n      this._closeTableCell({\n        colspan: optionsObjectOrColspan,\n        rowspan: rowspan,\n      });\n    }\n  }\n\n  _closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow () {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object | number } [optionsObjectOrColSpacing]\n   * Object holding the parameters of the table.\n   *\n   * Number value is depreceted.\n   *\n   * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]\n   * Number of spaces between table columns.\n   *\n   * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]\n   * Number of empty lines between table rows.\n   *\n   * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { number } [rowSpacing]\n   * Deprecated.\n   *\n   * @param { number } [leadingLineBreaks]\n   * Deprecated.\n   *\n   * @param { number } [trailingLineBreaks]\n   * Deprecated.\n   */\n  closeTable (\n    optionsObjectOrColSpacing = {},\n    rowSpacing = undefined,\n    leadingLineBreaks = undefined,\n    trailingLineBreaks = undefined\n  ) {\n    if (typeof optionsObjectOrColSpacing === 'object') {\n      this._closeTable(optionsObjectOrColSpacing);\n    } else {\n      this._closeTable({\n        colSpacing: optionsObjectOrColSpacing,\n        leadingLineBreaks: leadingLineBreaks,\n        rowSpacing: rowSpacing,\n        trailingLineBreaks: trailingLineBreaks\n      });\n    }\n  }\n\n  _closeTable ({ colSpacing = 3, rowSpacing = 0, leadingLineBreaks = 2, trailingLineBreaks = 2 } = {}) {\n    const table = this._popStackItem();\n    const output = tableToString(table.rows, rowSpacing, colSpacing);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n\n}\n\nfunction getText (stackItem) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks and table cells can be requested for text contents.');\n  }\n  return (stackItem.inlineTextBuilder.isEmpty())\n    ? stackItem.rawText\n    : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\nmodule.exports = { BlockTextBuilder: BlockTextBuilder };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}