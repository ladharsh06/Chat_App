{"ast":null,"code":"let updateQueue = makeQueue();\nconst raf = fn => schedule(fn, updateQueue);\nlet writeQueue = makeQueue();\nraf.write = fn => schedule(fn, writeQueue);\nlet onStartQueue = makeQueue();\nraf.onStart = fn => schedule(fn, onStartQueue);\nlet onFrameQueue = makeQueue();\nraf.onFrame = fn => schedule(fn, onFrameQueue);\nlet onFinishQueue = makeQueue();\nraf.onFinish = fn => schedule(fn, onFinishQueue);\nlet timeouts = [];\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel);\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n  let timeout = {\n    time,\n    handler,\n    cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\nlet findTimeout = time => ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length);\nraf.cancel = fn => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\nraf.sync = fn => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\nraf.throttle = fn => {\n  let lastArgs;\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n  throttled.handler = fn;\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n  return throttled;\n};\nlet nativeRaf = typeof window != 'undefined' ? window.requestAnimationFrame : () => {};\nraf.use = impl => nativeRaf = impl;\nraf.now = typeof performance != 'undefined' ? () => performance.now() : Date.now;\nraf.batchedUpdates = fn => fn();\nraf.catch = console.error;\nraf.frameLoop = 'always';\nraf.advance = () => {\n  if (raf.frameLoop !== 'demand') {\n    console.warn('Cannot call the manual advancement of rafz whilst frameLoop is not set as demand');\n  } else {\n    update();\n  }\n};\nlet ts = -1;\nlet sync = false;\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    if (raf.frameLoop !== 'demand') {\n      nativeRaf(loop);\n    }\n  }\n}\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler());\n    __raf.count -= count;\n  }\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, fn => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n  };\n}\nfunction eachSafely(values, each) {\n  values.forEach(value => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\nconst __raf = {\n  count: 0,\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n};\nexport { __raf, raf };","map":{"version":3,"names":["updateQueue","makeQueue","raf","fn","schedule","writeQueue","write","onStartQueue","onStart","onFrameQueue","onFrame","onFinishQueue","onFinish","timeouts","setTimeout","handler","ms","time","now","cancel","i","findIndex","t","splice","__raf","count","timeout","findTimeout","start","length","delete","sync","batchedUpdates","throttle","lastArgs","queuedFn","throttled","args","nativeRaf","window","requestAnimationFrame","use","impl","performance","Date","catch","console","error","frameLoop","advance","warn","update","ts","queue","add","loop","prevTs","eachSafely","flush","Math","min","next","Set","current","has","arg","size","values","each","forEach","value","e","clear"],"sources":["C:/Users/HARSH/Downloads/CHAT_APPLICATION-main (1)/CHAT_APPLICATION-main/node_modules/@react-spring/rafz/dist/react-spring-rafz.esm.js"],"sourcesContent":["let updateQueue = makeQueue();\nconst raf = fn => schedule(fn, updateQueue);\nlet writeQueue = makeQueue();\n\nraf.write = fn => schedule(fn, writeQueue);\n\nlet onStartQueue = makeQueue();\n\nraf.onStart = fn => schedule(fn, onStartQueue);\n\nlet onFrameQueue = makeQueue();\n\nraf.onFrame = fn => schedule(fn, onFrameQueue);\n\nlet onFinishQueue = makeQueue();\n\nraf.onFinish = fn => schedule(fn, onFinishQueue);\n\nlet timeouts = [];\n\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel);\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n\n  let timeout = {\n    time,\n    handler,\n    cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\n\nlet findTimeout = time => ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length);\n\nraf.cancel = fn => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\n\nraf.sync = fn => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\n\nraf.throttle = fn => {\n  let lastArgs;\n\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n\n  throttled.handler = fn;\n\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n\n  return throttled;\n};\n\nlet nativeRaf = typeof window != 'undefined' ? window.requestAnimationFrame : () => {};\n\nraf.use = impl => nativeRaf = impl;\n\nraf.now = typeof performance != 'undefined' ? () => performance.now() : Date.now;\n\nraf.batchedUpdates = fn => fn();\n\nraf.catch = console.error;\nraf.frameLoop = 'always';\n\nraf.advance = () => {\n  if (raf.frameLoop !== 'demand') {\n    console.warn('Cannot call the manual advancement of rafz whilst frameLoop is not set as demand');\n  } else {\n    update();\n  }\n};\n\nlet ts = -1;\nlet sync = false;\n\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n\n    if (raf.frameLoop !== 'demand') {\n      nativeRaf(loop);\n    }\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\n\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler());\n    __raf.count -= count;\n  }\n\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\n\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, fn => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n\n  };\n}\n\nfunction eachSafely(values, each) {\n  values.forEach(value => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\n\nconst __raf = {\n  count: 0,\n\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n\n};\n\nexport { __raf, raf };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}